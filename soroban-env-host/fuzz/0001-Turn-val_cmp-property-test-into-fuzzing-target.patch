From 515da6efe1b2cb997a6bc50e837afc49409d74f4 Mon Sep 17 00:00:00 2001
From: Guy Repta <50716988+gtrepta@users.noreply.github.com>
Date: Fri, 20 Dec 2024 21:40:24 +0000
Subject: [PATCH] Turn val_cmp property test into fuzzing target

---
 rust-toolchain.toml                     |   2 +-
 soroban-sdk/src/testutils.rs            |   2 +-
 tests/fuzz/fuzz/Cargo.toml              |   8 ++
 tests/fuzz/fuzz/fuzz_targets/val_cmp.rs | 141 ++++++++++++++++++++++++
 4 files changed, 151 insertions(+), 2 deletions(-)
 create mode 100644 tests/fuzz/fuzz/fuzz_targets/val_cmp.rs

diff --git a/rust-toolchain.toml b/rust-toolchain.toml
index e340b76..f3f78d7 100644
--- a/rust-toolchain.toml
+++ b/rust-toolchain.toml
@@ -1,4 +1,4 @@
 [toolchain]
-channel = "stable"
+channel = "nightly"
 targets = ["wasm32-unknown-unknown"]
 components = ["rustc", "cargo", "rustfmt", "clippy", "rust-src"]
diff --git a/soroban-sdk/src/testutils.rs b/soroban-sdk/src/testutils.rs
index 55ba0b2..f3fc060 100644
--- a/soroban-sdk/src/testutils.rs
+++ b/soroban-sdk/src/testutils.rs
@@ -319,7 +319,7 @@ pub mod budget {
     /// # #[cfg(not(feature = "testutils"))]
     /// # fn main() { }
     /// ```
-    pub struct Budget(pub(crate) crate::env::internal::budget::Budget);
+    pub struct Budget(pub crate::env::internal::budget::Budget);
 
     impl Display for Budget {
         fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
diff --git a/tests/fuzz/fuzz/Cargo.toml b/tests/fuzz/fuzz/Cargo.toml
index ab7af11..8cdccd3 100644
--- a/tests/fuzz/fuzz/Cargo.toml
+++ b/tests/fuzz/fuzz/Cargo.toml
@@ -10,7 +10,9 @@ cargo-fuzz = true
 [dependencies]
 libfuzzer-sys = "0.4"
 soroban-sdk = { path = "../../../soroban-sdk", features = [ "testutils" ]}
+soroban-env-host = { version = "=22.0.0-rc.1.1", features = [ "testutils" ] }
 test_fuzz = { path = "..", features = [ "testutils" ] }
+honggfuzz = "0.5"
 
 # Prevent this from interfering with workspaces
 [workspace]
@@ -24,3 +26,9 @@ name = "fuzz_target_1"
 path = "fuzz_targets/fuzz_target_1.rs"
 test = false
 doc = false
+
+[[bin]]
+name = "val_cmp"
+path = "fuzz_targets/val_cmp.rs"
+test = false
+doc = false
diff --git a/tests/fuzz/fuzz/fuzz_targets/val_cmp.rs b/tests/fuzz/fuzz/fuzz_targets/val_cmp.rs
new file mode 100644
index 0000000..e0f30ab
--- /dev/null
+++ b/tests/fuzz/fuzz/fuzz_targets/val_cmp.rs
@@ -0,0 +1,141 @@
+//! Check that Val and ScVal can be converted between each other,
+//! and that their comparison functions are equivalent.
+
+use core::cmp::Ordering;
+use honggfuzz::fuzz;
+use soroban_env_host::Compare;
+use soroban_sdk::testutils::arbitrary::{arbitrary, Arbitrary, SorobanArbitrary};
+use soroban_sdk::xdr::ScVal;
+use soroban_sdk::Env;
+use soroban_sdk::Val;
+use soroban_sdk::{FromVal, TryFromVal};
+
+#[derive(Arbitrary, Debug)]
+struct Input {
+    a: <Val as SorobanArbitrary>::Prototype,
+    b: <Val as SorobanArbitrary>::Prototype,
+}
+
+fn main() {
+    loop {
+        fuzz!(|input: Input| {
+            let rawval_proto_1 = input.a;
+            let rawval_proto_2 = input.b;
+
+            let env = &Env::default();
+            let budget = env.budget().0;
+
+            let rawval_1 = Val::from_val(env, &rawval_proto_1);
+            let rawval_2 = Val::from_val(env, &rawval_proto_2);
+
+            let (scval_1, scval_2) = {
+                let scval_1 = ScVal::try_from_val(env, &rawval_1);
+                let scval_2 = ScVal::try_from_val(env, &rawval_2);
+
+                let scval_1 = match scval_1 {
+                    Ok(scval_1) => scval_1,
+                    Err(e) => {
+                        panic!(
+                            "couldn't convert rawval to scval:\n\
+                         {rawval_1:?},\n\
+                         {e:#?}"
+                        );
+                    }
+                };
+
+                let scval_2 = match scval_2 {
+                    Ok(scval_2) => scval_2,
+                    Err(e) => {
+                        panic!(
+                            "couldn't convert rawval to scval:\n\
+                         {rawval_2:?},\n\
+                         {e:#?}"
+                        );
+                    }
+                };
+
+                (scval_1, scval_2)
+            };
+
+            // Check the comparison functions
+            {
+                let rawval_cmp = env.compare(&rawval_1, &rawval_2);
+                let rawval_cmp = rawval_cmp.expect("cmp");
+                let scval_cmp = Ord::cmp(&scval_1, &scval_2);
+
+                let rawval_cmp_is_eq = rawval_cmp == Ordering::Equal;
+
+                if rawval_cmp != scval_cmp {
+                    panic!(
+                        "rawval and scval don't compare the same:\n\
+                     {rawval_1:#?}\n\
+                     {rawval_2:#?}\n\
+                     {rawval_cmp:#?}\n\
+                     {scval_1:#?}\n\
+                     {scval_2:#?}\n\
+                     {scval_cmp:#?}"
+                    );
+                }
+
+                let scval_cmp_partial = PartialOrd::partial_cmp(&scval_1, &scval_2);
+
+                assert_eq!(Some(scval_cmp), scval_cmp_partial);
+
+                let scval_partial_eq = PartialEq::eq(&scval_1, &scval_2);
+                assert_eq!(rawval_cmp_is_eq, scval_partial_eq);
+
+                // Compare<ScVal> for Budget
+                let scval_budget_cmp = budget.compare(&scval_1, &scval_2);
+                let scval_budget_cmp = scval_budget_cmp.expect("cmp");
+                if rawval_cmp != scval_budget_cmp {
+                    panic!(
+                        "rawval and scval (budget) don't compare the same:\n\
+                     {rawval_1:#?}\n\
+                     {rawval_2:#?}\n\
+                     {rawval_cmp:#?}\n\
+                     {scval_1:#?}\n\
+                     {scval_2:#?}\n\
+                     {scval_budget_cmp:#?}"
+                    );
+                }
+            }
+
+            // Roundtrip checks
+            {
+                let rawval_after_1 = Val::try_from_val(env, &scval_1);
+                let rawval_after_1 = match rawval_after_1 {
+                    Ok(rawval_after_1) => rawval_after_1,
+                    Err(e) => {
+                        panic!(
+                            "couldn't convert scval to rawval:\n\
+                         {scval_1:?},\n\
+                         {e:#?}"
+                        );
+                    }
+                };
+
+                let rawval_cmp_before_after_1 =
+                    env.compare(&rawval_1, &rawval_after_1).expect("compare");
+
+                assert_eq!(rawval_cmp_before_after_1, Ordering::Equal);
+
+                let rawval_after_2 = Val::try_from_val(env, &scval_2);
+                let rawval_after_2 = match rawval_after_2 {
+                    Ok(rawval_after_2) => rawval_after_2,
+                    Err(e) => {
+                        panic!(
+                            "couldn't convert scval to rawval:\n\
+                         {scval_2:?},\n\
+                         {e:#?}"
+                        );
+                    }
+                };
+
+                let rawval_cmp_before_after_2 =
+                    env.compare(&rawval_2, &rawval_after_2).expect("compare");
+
+                assert_eq!(rawval_cmp_before_after_2, Ordering::Equal);
+            }
+        });
+    }
+}
-- 
2.34.1

